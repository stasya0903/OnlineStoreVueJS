let express,listEndpoints,history,httpServer;_34e‍.x([["default",()=>_34e‍.o]]);_34e‍.w("express",[["default",["express"],function(v){express=v}]]);_34e‍.w("express-list-endpoints",[["default",["listEndpoints"],function(v){listEndpoints=v}]]);_34e‍.w("connect-history-api-fallback",[["default",["history"],function(v){history=v}]]);_34e‍.w("http",[["default",["httpServer"],function(v){httpServer=v}]]);




const _34e‍anonymous=({
  port,
  host,
  srvPath,
  distPath,
  hasTypescript,
  shouldServeApp,
  isInProduction,
}) => {
  return new Promise((resolve, reject) => {
    const app = express();
    const http = httpServer.Server(app);

    if (hasTypescript) {
      require('ts-node/register/transpile-only');
    }

    const server = loadServer(srvPath);

    server(app, http);

    if (isInProduction && shouldServeApp) {
      app.use(history());
      app.use(express.static(distPath));
    }

    http.listen(port, host, err => {
      if (err) {
        reject(err);
      } else {
        resolve(getAppEndpoints(app));
      }
    });
  });
};_34e‍.d(_34e‍anonymous);

function getAppEndpoints (app) {
  try {
    return listEndpoints(app);
  } catch (e) {
    return [];
  }
}

function loadServer (file) {
  const moduleIsAvailable = () => {
    try {
      require.resolve(file);
      return true;
    } catch (e) {
      return false;
    }
  };

  const empty = () => {};

  if (!moduleIsAvailable()) {
    return empty;
  }

  const module = require(file);
  return module.default || module || empty;
}
