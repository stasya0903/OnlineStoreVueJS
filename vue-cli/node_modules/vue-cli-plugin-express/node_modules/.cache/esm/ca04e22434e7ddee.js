let serverUrl,logSuccessLunch,server;_34e‍.x([["default",()=>_34e‍.o]]);_34e‍.w("../utils/serverUrl",[["default",["serverUrl"],function(v){serverUrl=v}]]);_34e‍.w("../utils/logSuccessLaunch",[["default",["logSuccessLunch"],function(v){logSuccessLunch=v}]]);_34e‍.w("../server",[["default",["server"],function(v){server=v}]]);



const _34e‍anonymous=({
  defaultOptions,
  srvPath,
  shouldServeApp,
  isInProduction,
  distPath,
  hasTypescript,
}) => args => {
  const run = async (resolve) => {
    const {
      port,
      host,
      localUrl,
      networkUrl,
      localUrlForTerminal,
    } = await serverUrl.findServerUrl(args, defaultOptions);

    const routes = await server({
      port,
      host,
      srvPath,
      distPath,
      hasTypescript,
      shouldServeApp,
      isInProduction,
    });

    if (shouldServeApp && !isInProduction) {
      serverUrl.writeToFile(localUrl);
    }

    logSuccessLunch({
      urls: { local: localUrlForTerminal, network: networkUrl },
      routes,
      isInProduction,
      shouldServeApp,
    });

    resolve();
  };

  return new Promise((resolve) => {
    if (args.delay) {
      setTimeout(() => run(resolve), 300);
    } else {
      run(resolve);
    }
  });
};_34e‍.d(_34e‍anonymous);
